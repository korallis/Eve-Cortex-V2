#!/usr/bin/env node

/**
 * Automated Task Completion Workflow
 * This script handles the complete lifecycle of task completion:
 * 1. Creates a feature branch
 * 2. Commits changes
 * 3. Creates a PR
 * 4. Monitors CI status
 * 5. Attempts to fix issues if CI fails
 * 6. Auto-merges when all checks pass
 */

const { execSync } = require('child_process')
const fs = require('fs')
const path = require('path')

class AutomatedTaskCompletion {
  constructor(taskName, taskDescription, requirements = []) {
    this.taskName = taskName
    this.taskDescription = taskDescription
    this.requirements = requirements
    this.branchName = `task/${taskName.toLowerCase().replace(/\s+/g, '-')}`
    this.repoInfo = null
  }

  async initialize() {
    try {
      // Get repository information
      const repoInfoOutput = execSync('gh repo view --json owner,name', { encoding: 'utf8' })
      this.repoInfo = JSON.parse(repoInfoOutput)
      console.log(`üìã Repository: ${this.repoInfo.owner.login}/${this.repoInfo.name}`)
    } catch (error) {
      console.error('‚ùå Failed to get repository information:', error.message)
      throw error
    }
  }

  async createFeatureBranch() {
    try {
      console.log(`üåø Creating feature branch: ${this.branchName}`)

      // Ensure we're on main and up to date
      execSync('git checkout main', { stdio: 'pipe' })
      execSync('git pull origin main', { stdio: 'pipe' })

      // Create and checkout feature branch
      execSync(`git checkout -b ${this.branchName}`, { stdio: 'pipe' })

      console.log(`‚úÖ Created and switched to branch: ${this.branchName}`)
    } catch (error) {
      console.error('‚ùå Failed to create feature branch:', error.message)
      throw error
    }
  }

  async commitChanges() {
    try {
      console.log('üìù Committing changes...')

      // Add all changes
      execSync('git add .', { stdio: 'pipe' })

      // Check if there are changes to commit
      try {
        execSync('git diff --cached --exit-code', { stdio: 'pipe' })
        console.log('‚ÑπÔ∏è No changes to commit')
        return false
      } catch {
        // There are changes to commit
      }

      // Create commit message
      const commitMessage = `feat: ${this.taskName}

${this.taskDescription}

${this.requirements.length > 0 ? `Requirements addressed: ${this.requirements.join(', ')}` : ''}

Auto-generated by automated task completion workflow`

      execSync(`git commit -m "${commitMessage}"`, { stdio: 'pipe' })
      console.log('‚úÖ Changes committed successfully')
      return true
    } catch (error) {
      console.error('‚ùå Failed to commit changes:', error.message)
      throw error
    }
  }

  async pushBranch() {
    try {
      console.log(`üöÄ Pushing branch to origin...`)
      execSync(`git push origin ${this.branchName}`, { stdio: 'pipe' })
      console.log('‚úÖ Branch pushed successfully')
    } catch (error) {
      console.error('‚ùå Failed to push branch:', error.message)
      throw error
    }
  }

  async createPullRequest() {
    try {
      console.log('üìã Creating pull request...')

      const prBody = `## üéØ Task Completion: ${this.taskName}

${this.taskDescription}

### ‚úÖ Changes Made
- Implemented task requirements
- All quality gates should pass
- Ready for automated review and merge

### üîç Requirements Addressed
${this.requirements.map(req => `- ${req}`).join('\n')}

### ü§ñ Automated Workflow
This PR was created by the automated task completion workflow and will be:
1. ‚úÖ Automatically tested by CI/CD pipeline
2. üîß Auto-fixed if minor issues are detected
3. üöÄ Auto-merged when all checks pass

---
*Generated by automated task completion workflow*`

      const createPrCommand = `gh pr create --title "feat: ${this.taskName}" --body "${prBody}" --label "auto-merge,task-completion"`
      const prOutput = execSync(createPrCommand, { encoding: 'utf8' })

      // Extract PR number from output
      const prUrlMatch = prOutput.match(/https:\/\/github\.com\/[^\/]+\/[^\/]+\/pull\/(\d+)/)
      if (!prUrlMatch) {
        throw new Error('Failed to extract PR number from output')
      }

      const prNumber = parseInt(prUrlMatch[1])
      console.log(`‚úÖ Pull request created: #${prNumber}`)
      return prNumber
    } catch (error) {
      console.error('‚ùå Failed to create pull request:', error.message)
      throw error
    }
  }

  async monitorCIStatus(prNumber, maxWaitTime = 600000) {
    // 10 minutes max
    console.log(`üîç Monitoring CI status for PR #${prNumber}...`)

    const startTime = Date.now()
    let lastStatus = null

    while (Date.now() - startTime < maxWaitTime) {
      try {
        // Get PR status using GitHub CLI
        const statusOutput = execSync(`gh pr view ${prNumber} --json statusCheckRollup`, {
          encoding: 'utf8',
        })
        const statusData = JSON.parse(statusOutput)

        const checks = statusData.statusCheckRollup || []
        const pending = checks.filter(
          check => check.state === 'PENDING' || check.state === 'QUEUED'
        )
        const failed = checks.filter(check => check.state === 'FAILURE' || check.state === 'ERROR')
        const passed = checks.filter(check => check.state === 'SUCCESS')

        const currentStatus = {
          total: checks.length,
          pending: pending.length,
          failed: failed.length,
          passed: passed.length,
        }

        // Only log if status changed
        if (JSON.stringify(currentStatus) !== JSON.stringify(lastStatus)) {
          console.log(
            `üìä CI Status: ${passed.length}/${checks.length} passed, ${pending.length} pending, ${failed.length} failed`
          )
          lastStatus = currentStatus
        }

        // If no checks are running, wait a bit for them to start
        if (checks.length === 0) {
          console.log('‚è≥ Waiting for CI checks to start...')
          await this.sleep(10000) // Wait 10 seconds
          continue
        }

        // If all checks passed
        if (failed.length === 0 && pending.length === 0 && passed.length > 0) {
          console.log('‚úÖ All CI checks passed!')
          return { success: true, checks }
        }

        // If any checks failed
        if (failed.length > 0 && pending.length === 0) {
          console.log('‚ùå CI checks failed')
          console.log('Failed checks:')
          failed.forEach(check => {
            console.log(`  ‚Ä¢ ${check.name}: ${check.description || 'No description'}`)
          })
          return { success: false, checks, failed }
        }

        // Wait before checking again
        await this.sleep(30000) // Wait 30 seconds
      } catch (error) {
        console.error('‚ö†Ô∏è Error checking CI status:', error.message)
        await this.sleep(30000)
      }
    }

    console.log('‚è∞ Timeout waiting for CI checks to complete')
    return { success: false, timeout: true }
  }

  async attemptAutoFix(prNumber, failedChecks) {
    console.log('üîß Attempting to auto-fix failed checks...')

    for (const check of failedChecks) {
      console.log(`üîç Analyzing failed check: ${check.name}`)

      try {
        switch (check.name) {
          case 'Code Quality':
            await this.fixCodeQuality()
            break
          case 'Tests':
            await this.fixTests()
            break
          case 'Build Test':
            await this.fixBuild()
            break
          case 'Security & Dependency Audit':
            await this.fixSecurity()
            break
          default:
            console.log(`‚ö†Ô∏è No auto-fix available for: ${check.name}`)
        }
      } catch (error) {
        console.error(`‚ùå Failed to fix ${check.name}:`, error.message)
      }
    }

    // Check if we made any fixes
    try {
      execSync('git diff --exit-code', { stdio: 'pipe' })
      console.log('‚ÑπÔ∏è No fixes were applied')
      return false
    } catch {
      // There are changes, commit and push them
      console.log('üìù Committing auto-fixes...')
      execSync('git add .', { stdio: 'pipe' })
      execSync('git commit -m "fix: automated fixes for CI failures"', { stdio: 'pipe' })
      execSync(`git push origin ${this.branchName}`, { stdio: 'pipe' })
      console.log('‚úÖ Auto-fixes committed and pushed')
      return true
    }
  }

  async fixCodeQuality() {
    console.log('üßπ Fixing code quality issues...')

    try {
      // Run ESLint with auto-fix
      execSync('npm run lint:fix', { stdio: 'pipe' })
      console.log('‚úÖ ESLint auto-fix completed')
    } catch (error) {
      console.log('‚ö†Ô∏è ESLint auto-fix had issues, but continuing...')
    }

    try {
      // Run Prettier
      execSync('npm run format', { stdio: 'pipe' })
      console.log('‚úÖ Prettier formatting completed')
    } catch (error) {
      console.log('‚ö†Ô∏è Prettier formatting had issues, but continuing...')
    }
  }

  async fixTests() {
    console.log('üß™ Attempting to fix test issues...')
    // For now, just log - more sophisticated test fixing would require AI analysis
    console.log('‚ÑπÔ∏è Test fixing requires manual intervention')
  }

  async fixBuild() {
    console.log('üèóÔ∏è Attempting to fix build issues...')

    try {
      // Clear Next.js cache
      execSync('rm -rf .next', { stdio: 'pipe' })
      console.log('‚úÖ Cleared Next.js cache')
    } catch (error) {
      console.log('‚ö†Ô∏è Failed to clear cache, but continuing...')
    }
  }

  async fixSecurity() {
    console.log('üîí Attempting to fix security issues...')

    try {
      // Run npm audit fix
      execSync('npm audit fix', { stdio: 'pipe' })
      console.log('‚úÖ npm audit fix completed')
    } catch (error) {
      console.log('‚ö†Ô∏è npm audit fix had issues, but continuing...')
    }
  }

  async autoMergePR(prNumber) {
    try {
      console.log(`ü§ñ Auto-merging PR #${prNumber}...`)

      // Enable auto-merge
      execSync(`gh pr merge ${prNumber} --auto --squash --delete-branch`, { stdio: 'pipe' })

      console.log('‚úÖ Auto-merge enabled - PR will merge when all checks pass')
      return true
    } catch (error) {
      console.error('‚ùå Failed to enable auto-merge:', error.message)
      return false
    }
  }

  async sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  async run() {
    try {
      await this.initialize()
      await this.createFeatureBranch()

      const hasChanges = await this.commitChanges()
      if (!hasChanges) {
        console.log('‚ÑπÔ∏è No changes to process, exiting...')
        return
      }

      await this.pushBranch()
      const prNumber = await this.createPullRequest()

      // Monitor CI status
      const ciResult = await this.monitorCIStatus(prNumber)

      if (ciResult.success) {
        // All checks passed, enable auto-merge
        await this.autoMergePR(prNumber)
      } else if (ciResult.failed && !ciResult.timeout) {
        // Some checks failed, attempt auto-fix
        const fixesApplied = await this.attemptAutoFix(prNumber, ciResult.failed)

        if (fixesApplied) {
          console.log('üîÑ Fixes applied, monitoring CI again...')
          const retryResult = await this.monitorCIStatus(prNumber)

          if (retryResult.success) {
            await this.autoMergePR(prNumber)
          } else {
            console.log('‚ùå Auto-fixes did not resolve all issues - manual intervention required')
          }
        } else {
          console.log('‚ùå No auto-fixes available - manual intervention required')
        }
      } else {
        console.log('‚è∞ CI checks timed out - manual intervention may be required')
      }
    } catch (error) {
      console.error('‚ùå Automated task completion failed:', error.message)
      process.exit(1)
    }
  }
}

// CLI interface
async function main() {
  const taskName = process.argv[2]
  const taskDescription = process.argv[3]
  const requirements = process.argv.slice(4)

  if (!taskName || !taskDescription) {
    console.log('ü§ñ Automated Task Completion Workflow')
    console.log('')
    console.log('Usage:')
    console.log(
      '  node scripts/automated-task-completion.js "Task Name" "Task Description" [requirements...]'
    )
    console.log('')
    console.log('Example:')
    console.log(
      '  node scripts/automated-task-completion.js "Setup CI/CD" "Implement comprehensive CI/CD pipeline" "9.1" "9.3"'
    )
    process.exit(1)
  }

  const workflow = new AutomatedTaskCompletion(taskName, taskDescription, requirements)
  await workflow.run()
}

if (require.main === module) {
  main().catch(console.error)
}

module.exports = AutomatedTaskCompletion
